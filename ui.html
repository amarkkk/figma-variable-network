<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Variable Network Explorer</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      background: #1e1e1e;
      color: #e0e0e0;
      overflow: hidden;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .header {
      background: #2d2d2d;
      padding: 12px 16px;
      border-bottom: 1px solid #3d3d3d;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .header-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-row.stats {
      gap: 16px;
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .stat-label {
      font-size: 11px;
      color: #888;
    }

    .stat-value {
      font-size: 14px;
      font-weight: 600;
      color: #0d99ff;
    }

    .collections-label {
      font-size: 11px;
      color: #888;
      flex-shrink: 0;
    }

    .collection-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      flex: 1;
    }

    .collection-filter-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      background: #1e1e1e;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .collection-filter-item:hover {
      border-color: #0d99ff;
    }

    .collection-filter-item input[type="checkbox"] {
      margin: 0;
      cursor: pointer;
    }

    .header-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .search-bar {
      flex: 1;
      padding: 6px 10px;
      background: #1e1e1e;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 12px;
    }

    .search-bar:focus {
      outline: none;
      border-color: #0d99ff;
    }

    .refresh-btn {
      padding: 6px 12px;
      background: #0d99ff;
      border: none;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .refresh-btn:hover {
      background: #0b7acc;
    }

    .filter-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: #1e1e1e;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .filter-toggle:hover {
      border-color: #0d99ff;
    }

    .filter-toggle.active {
      background: #0d99ff;
      border-color: #0d99ff;
      color: #fff;
    }

    .filter-toggle input[type="checkbox"] {
      margin: 0;
      cursor: pointer;
    }

    .tabs {
      display: flex;
      background: #2d2d2d;
      border-bottom: 1px solid #3d3d3d;
      justify-content: space-between;
      align-items: center;
    }

    .tabs-left {
      display: flex;
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .tab:hover {
      background: #3d3d3d;
    }

    .tab.active {
      border-bottom-color: #0d99ff;
      color: #0d99ff;
    }

    .format-toggle {
      display: flex;
      gap: 4px;
      margin-right: 12px;
      background: #1e1e1e;
      border-radius: 4px;
      padding: 4px;
    }

    .format-btn {
      padding: 6px 12px;
      background: transparent;
      border: none;
      color: #888;
      cursor: pointer;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .format-btn:hover {
      color: #e0e0e0;
    }

    .format-btn.active {
      background: #0d99ff;
      color: #fff;
    }

    .content {
      flex: 1;
      overflow: auto;
      padding: 16px;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #888;
    }

    .tree-view {
      display: none;
    }

    .tree-view.active {
      display: block;
    }

    .variable-node {
      margin-bottom: 4px;
    }

    .variable-item {
      padding: 8px 12px;
      background: #2d2d2d;
      border-radius: 4px;
      margin-bottom: 2px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
      user-select: none;
      border-left: 3px solid #3d3d3d;
    }

    .variable-item:hover {
      background: #3d3d3d;
    }

    .variable-item.has-usage {
      border-left-color: #0d99ff;
    }

    .variable-item.search-match {
      background: #394360;
    }

    .expand-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #888;
      flex-shrink: 0;
    }

    .variable-name {
      font-weight: 500;
      flex: 1;
    }

    .variable-name mark {
      background-color: rgba(255, 140, 0, 0.3);
      color: inherit;
      padding: 0;
      border-radius: 2px;
    }

    .usage-count {
      font-size: 10px;
      color: #888;
      background: #1e1e1e;
      padding: 2px 8px;
      border-radius: 3px;
      font-weight: 600;
      cursor: help;
    }

    .usage-count.has-usage {
      color: #0d99ff;
    }

    .usage-breakdown-tooltip {
      position: absolute;
      top: 100%;
      right: 0;
      background: #2d2d2d;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      padding: 8px 12px;
      z-index: 100;
      min-width: 180px;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .usage-count:hover + .usage-breakdown-tooltip,
    .usage-breakdown-tooltip:hover {
      display: block;
    }

    .usage-breakdown-row {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      padding: 2px 0;
    }

    .usage-breakdown-row .label {
      color: #888;
    }

    .usage-breakdown-row .value {
      font-weight: 600;
    }

    .usage-breakdown-row.component .value {
      color: #a855f7;
    }

    .usage-breakdown-row.instance .value {
      color: #22c55e;
    }

    .usage-breakdown-row.detached .value {
      color: #f59e0b;
    }

    .usage-breakdown-row.total .value {
      color: #0d99ff;
    }

    .component-selector {
      display: none;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      background: #0d99ff;
      border-radius: 3px;
    }

    .variable-item:hover .component-selector {
      display: flex;
    }

    .component-nav-btn {
      background: transparent;
      border: none;
      color: #fff;
      cursor: pointer;
      padding: 0 2px;
      font-size: 12px;
    }

    .component-nav-btn:hover {
      color: #7cc4f8;
    }

    .component-nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .component-info {
      font-size: 10px;
      color: #fff;
      cursor: pointer;
    }

    .component-info:hover {
      text-decoration: underline;
    }

    .node-type-badge {
      font-size: 8px;
      padding: 1px 4px;
      border-radius: 2px;
      margin-left: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .node-type-badge.component {
      background: #a855f7;
      color: #fff;
    }

    .node-type-badge.instance {
      background: #22c55e;
      color: #fff;
    }

    .node-type-badge.detached {
      background: #f59e0b;
      color: #000;
    }

    .selection-feedback {
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: #2d2d2d;
      border: 1px solid #0d99ff;
      border-radius: 4px;
      padding: 8px 12px;
      z-index: 1000;
      font-size: 11px;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .selection-feedback.visible {
      display: block;
    }

    .selection-feedback.error {
      border-color: #f44336;
    }

    .selection-feedback .node-name {
      font-weight: 600;
      color: #0d99ff;
    }

    .selection-feedback .page-name {
      color: #888;
      font-size: 10px;
    }

    .color-preview {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid #3d3d3d;
      flex-shrink: 0;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .variable-item:hover .color-preview {
      opacity: 1;
    }

    .children {
      margin-left: 24px;
      border-left: 1px solid #3d3d3d;
      padding-left: 12px;
      margin-top: 4px;
      display: none;
    }

    .children.expanded {
      display: block;
    }

    .graph-view {
      display: none;
      height: 100%;
      position: relative;
    }

    .graph-view.active {
      display: block;
    }

    .graph-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .graph-btn {
      padding: 6px 12px;
      background: #2d2d2d;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }

    .graph-btn:hover {
      background: #3d3d3d;
      border-color: #0d99ff;
    }

    #graph-canvas {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #graph-canvas:active {
      cursor: grabbing;
    }

    .tooltip {
      position: fixed;
      background: #2d2d2d;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      padding: 8px 12px;
      pointer-events: none;
      z-index: 1000;
      max-width: 300px;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .tooltip.visible {
      display: block;
    }

    .tooltip-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .tooltip-row {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      font-size: 11px;
      margin-top: 2px;
    }

    .tooltip-label {
      color: #888;
    }

    .empty-state {
      text-align: center;
      color: #888;
      padding: 40px;
    }

    /* Type pre-filter screen */
    .type-filter-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: 40px;
    }

    .type-filter-screen.hidden {
      display: none;
    }

    .type-filter-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .type-filter-subtitle {
      font-size: 12px;
      color: #888;
      margin-bottom: 24px;
    }

    .type-filter-options {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 24px;
    }

    .type-filter-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px 24px;
      background: #2d2d2d;
      border: 2px solid #3d3d3d;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 100px;
    }

    .type-filter-option:hover {
      border-color: #555;
    }

    .type-filter-option.selected {
      border-color: #0d99ff;
      background: #1a3a5c;
    }

    .type-filter-option input[type="checkbox"] {
      display: none;
    }

    .type-filter-icon {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .type-filter-icon.color {
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
      border-radius: 4px;
    }

    .type-filter-name {
      font-weight: 500;
      margin-bottom: 4px;
    }

    .type-filter-count {
      font-size: 11px;
      color: #888;
    }

    .type-filter-load-btn {
      padding: 12px 32px;
      background: #0d99ff;
      border: none;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .type-filter-load-btn:hover {
      background: #0b7acc;
    }

    .type-filter-load-btn:disabled {
      background: #3d3d3d;
      cursor: not-allowed;
    }

    /* Main content wrapper */
    .main-content {
      display: none;
      flex-direction: column;
      height: 100%;
    }

    .main-content.visible {
      display: flex;
    }

    /* Variable type badge */
    .var-type-badge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
      text-transform: uppercase;
      margin-left: 6px;
    }

    .var-type-badge.color {
      background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
      color: #fff;
    }

    .var-type-badge.float {
      background: #8b5cf6;
      color: #fff;
    }

    .var-type-badge.string {
      background: #10b981;
      color: #fff;
    }

    .var-type-badge.boolean {
      background: #f59e0b;
      color: #000;
    }

    /* Value preview for non-color types */
    .value-preview {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 10px;
      color: #888;
      background: #1e1e1e;
      padding: 2px 6px;
      border-radius: 3px;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .value-preview.number {
      color: #8b5cf6;
    }

    .value-preview.string {
      color: #10b981;
    }

    .value-preview.boolean {
      color: #f59e0b;
    }

    /* Active type filters in header */
    .active-type-filters {
      display: flex;
      gap: 6px;
      margin-left: 12px;
    }

    .active-type-chip {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
      background: #3d3d3d;
    }

    .back-to-filter-btn {
      padding: 6px 12px;
      background: #3d3d3d;
      border: none;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }

    .back-to-filter-btn:hover {
      background: #4d4d4d;
    }

    /* Resize Handle */
    #resize-corner {
      position: fixed;
      right: 4px;
      bottom: 4px;
      cursor: nwse-resize;
      z-index: 10000;
      opacity: 0.4;
      color: #888;
    }

    #resize-corner:hover {
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Type Pre-Filter Screen -->
    <div class="type-filter-screen" id="type-filter-screen">
      <div class="type-filter-title">Variable Network Explorer</div>
      <div class="type-filter-subtitle">Select which variable types to load</div>
      <div class="type-filter-options" id="type-filter-options">
        <label class="type-filter-option selected" data-type="COLOR">
          <input type="checkbox" checked>
          <div class="type-filter-icon color"></div>
          <div class="type-filter-name">Color</div>
          <div class="type-filter-count" id="count-color">0 variables</div>
        </label>
        <label class="type-filter-option" data-type="FLOAT">
          <input type="checkbox">
          <div class="type-filter-icon">123</div>
          <div class="type-filter-name">Number</div>
          <div class="type-filter-count" id="count-float">0 variables</div>
        </label>
        <label class="type-filter-option" data-type="STRING">
          <input type="checkbox">
          <div class="type-filter-icon">"Aa"</div>
          <div class="type-filter-name">String</div>
          <div class="type-filter-count" id="count-string">0 variables</div>
        </label>
        <label class="type-filter-option" data-type="BOOLEAN">
          <input type="checkbox">
          <div class="type-filter-icon">⊤⊥</div>
          <div class="type-filter-name">Boolean</div>
          <div class="type-filter-count" id="count-boolean">0 variables</div>
        </label>
      </div>
      <button class="type-filter-load-btn" id="load-variables-btn">Load Variables</button>
    </div>

    <!-- Main Content (hidden until types are selected) -->
    <div class="main-content" id="main-content">
      <div class="header">
        <!-- Row 1: Stats and controls -->
        <div class="header-row stats">
          <div class="stat-item">
            <span class="stat-label">Loaded:</span>
            <span class="stat-value" id="total-count">0</span>
            <div class="active-type-filters" id="active-type-filters"></div>
          </div>
          <span class="collections-label">Collections:</span>
        </div>

        <!-- Row 2: Collection filters -->
        <div class="header-row">
          <div class="collection-filters" id="collection-filters"></div>
        </div>

        <!-- Row 3: Controls -->
        <div class="header-row header-controls">
          <button class="back-to-filter-btn" id="back-to-filter-btn">← Change Types</button>
          <input type="text" id="search" class="search-bar" placeholder="Search variables...">
          <button class="refresh-btn" id="refresh-btn">↻ Refresh</button>
          <label class="filter-toggle" id="unconnected-filter">
            <input type="checkbox" id="unconnected-checkbox">
            <span>Show only unconnected</span>
          </label>
        </div>
      </div>

      <div class="tabs">
        <div class="tabs-left">
          <div class="tab active" data-view="tree">Tree View</div>
          <div class="tab" data-view="graph">Network Graph</div>
        </div>
        <div class="format-toggle" id="format-toggle">
          <button class="format-btn active" data-format="hex">HEX</button>
          <button class="format-btn" data-format="hsba">HSBA</button>
        </div>
      </div>

      <div class="content">
        <div id="loading" class="loading" style="display: none;">Loading variables...</div>
        <div id="tree-view" class="tree-view active"></div>

        <div class="graph-view" id="graph-view-container">
          <div class="graph-controls">
            <button class="graph-btn" id="graph-zoom-in">+</button>
            <button class="graph-btn" id="graph-zoom-out">−</button>
            <button class="graph-btn" id="graph-reset">Reset</button>
            <button class="graph-btn" id="graph-expand-all">Expand All</button>
            <button class="graph-btn" id="graph-orientation">↔ Horizontal</button>
          </div>
          <canvas id="graph-canvas"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>
  <div id="selection-feedback" class="selection-feedback"></div>

  <!-- Resize Handle -->
  <svg id="resize-corner" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256">
    <path d="M213.66,133.66l-80,80a8,8,0,0,1-11.32-11.32l80-80a8,8,0,0,1,11.32,11.32Zm-16-99.32a8,8,0,0,0-11.32,0l-152,152a8,8,0,0,0,11.32,11.32l152-152A8,8,0,0,0,197.66,34.34Z"></path>
  </svg>

  <script>
    let allVariables = [];
    let allRelationships = [];
    let filteredVariables = [];
    let colorFormat = 'hex';
    let showOnlyUnconnected = false;
    let searchQuery = '';
    let selectedCollections = new Set();
    let componentSelectionIndex = new Map();
    let expandedNodes = new Set();

    let graphZoom = 1;
    let graphPanX = 0;
    let graphPanY = 0;
    let graphOrientation = 'vertical';
    let collapsedNodes = new Set();
    let selectedNodeId = null;

    // Type filter state
    let selectedTypes = new Set(['COLOR']);
    let typeCounts = {};
    let hasLoadedOnce = false;

    // Initialize type filter checkboxes
    document.querySelectorAll('.type-filter-option').forEach(option => {
      const checkbox = option.querySelector('input[type="checkbox"]');
      const type = option.dataset.type;

      // Listen for the change event on the checkbox (triggered by label click or direct checkbox click)
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          selectedTypes.add(type);
          option.classList.add('selected');
        } else {
          selectedTypes.delete(type);
          option.classList.remove('selected');
        }

        updateLoadButtonState();
      });
    });

    function updateLoadButtonState() {
      const loadBtn = document.getElementById('load-variables-btn');
      loadBtn.disabled = selectedTypes.size === 0;
    }

    // Load variables button
    document.getElementById('load-variables-btn').addEventListener('click', () => {
      if (selectedTypes.size === 0) return;

      // Show main content, hide filter screen
      document.getElementById('type-filter-screen').classList.add('hidden');
      document.getElementById('main-content').classList.add('visible');
      document.getElementById('loading').style.display = 'flex';

      // Show/hide format toggle based on whether COLOR is selected
      const formatToggle = document.getElementById('format-toggle');
      formatToggle.style.display = selectedTypes.has('COLOR') ? 'flex' : 'none';

      // Update active type chips
      updateActiveTypeChips();

      // Request scan with selected types
      parent.postMessage({
        pluginMessage: {
          type: 'scan',
          types: Array.from(selectedTypes)
        }
      }, '*');

      hasLoadedOnce = true;
    });

    // Back to filter button
    document.getElementById('back-to-filter-btn').addEventListener('click', () => {
      document.getElementById('main-content').classList.remove('visible');
      document.getElementById('type-filter-screen').classList.remove('hidden');
    });

    function updateActiveTypeChips() {
      const container = document.getElementById('active-type-filters');
      container.innerHTML = '';

      const typeLabels = {
        'COLOR': 'Color',
        'FLOAT': 'Number',
        'STRING': 'String',
        'BOOLEAN': 'Boolean'
      };

      selectedTypes.forEach(type => {
        const chip = document.createElement('span');
        chip.className = 'active-type-chip';
        chip.textContent = typeLabels[type] || type;
        container.appendChild(chip);
      });
    }

    document.getElementById('refresh-btn').addEventListener('click', () => {
      document.getElementById('loading').style.display = 'flex';
      document.getElementById('tree-view').innerHTML = '';
      parent.postMessage({
        pluginMessage: {
          type: 'scan',
          types: Array.from(selectedTypes)
        }
      }, '*');
    });

    document.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        colorFormat = btn.dataset.format;
      });
    });

    document.getElementById('unconnected-checkbox').addEventListener('change', (e) => {
      showOnlyUnconnected = e.target.checked;
      document.getElementById('unconnected-filter').classList.toggle('active', showOnlyUnconnected);
      applyFilters();
    });

    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        const view = tab.dataset.view;
        document.getElementById('tree-view').classList.toggle('active', view === 'tree');
        document.getElementById('graph-view-container').classList.toggle('active', view === 'graph');
        
        if (view === 'graph') renderGraph();
      });
    });

    document.getElementById('search').addEventListener('input', applyFilters);

    function applyFilters() {
      searchQuery = document.getElementById('search').value.toLowerCase();
      
      if (searchQuery) {
        filteredVariables = allVariables.filter(v => 
          v.name.toLowerCase().includes(searchQuery) || 
          v.collection.toLowerCase().includes(searchQuery)
        );
      } else {
        filteredVariables = allVariables.filter(v => {
          const matchesUnconnected = !showOnlyUnconnected || isUnconnected(v);
          const matchesCollection = selectedCollections.size === 0 || selectedCollections.has(v.collection);
          return matchesUnconnected && matchesCollection;
        });
      }
      
      renderTreeView();
      if (document.getElementById('graph-view-container').classList.contains('active')) {
        renderGraph();
      }
    }

    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query})`, 'gi');
      return text.replace(regex, '<mark>$1</mark>');
    }

    function isUnconnected(variable) {
      const hasParents = allRelationships.some(r => r.to === variable.id);
      const hasChildren = allRelationships.some(r => r.from === variable.id);
      return !hasParents && !hasChildren;
    }

    function buildTree(varsToShow = allVariables) {
      const varMap = new Map();
      varsToShow.forEach(v => varMap.set(v.id, { ...v, children: [] }));
      
      const roots = [];
      
      varsToShow.forEach(variable => {
        const node = varMap.get(variable.id);
        const parentIds = new Set();
        
        Object.values(variable.references).forEach(refId => {
          if (refId) parentIds.add(refId);
        });
        
        if (parentIds.size === 0) {
          roots.push(node);
        } else {
          parentIds.forEach(parentId => {
            const parent = varMap.get(parentId);
            if (parent && !parent.children.includes(node)) {
              parent.children.push(node);
            }
          });
        }
      });
      
      function sortNodes(nodes) {
        nodes.sort((a, b) => a.name.localeCompare(b.name));
        nodes.forEach(node => {
          if (node.children && node.children.length > 0) {
            sortNodes(node.children);
          }
        });
      }
      
      sortNodes(roots);
      return roots;
    }

    function getPathToRoot(nodeId, varMap) {
      const path = [];
      let current = varMap.get(nodeId);
      
      while (current) {
        path.unshift(current);
        const parentRef = Object.values(current.references).find(r => r);
        current = parentRef ? varMap.get(parentRef) : null;
      }
      
      return path;
    }

    function renderTreeView() {
      const container = document.getElementById('tree-view');
      
      if (allVariables.length === 0) {
        container.innerHTML = '<div class="empty-state">No variables found</div>';
        return;
      }
      
      const varMap = new Map();
      allVariables.forEach(v => varMap.set(v.id, { ...v, children: [] }));
      
      allVariables.forEach(variable => {
        const node = varMap.get(variable.id);
        Object.values(variable.references).forEach(refId => {
          if (refId) {
            const parent = varMap.get(refId);
            if (parent && !parent.children.includes(node)) {
              parent.children.push(node);
            }
          }
        });
      });
      
      let varsToShow;
      let matchedIds = new Set();
      
      if (searchQuery) {
        filteredVariables.forEach(v => {
          matchedIds.add(v.id);
          const path = getPathToRoot(v.id, varMap);
          path.forEach(p => expandedNodes.add(p.id));
        });
        
        const topLevel = filteredVariables.filter(v => {
          const parentIds = Object.values(v.references).filter(r => r);
          return parentIds.length === 0;
        });
        
        const nested = filteredVariables.filter(v => {
          const parentIds = Object.values(v.references).filter(r => r);
          return parentIds.length > 0;
        });
        
        const nestedWithPaths = nested.map(v => getPathToRoot(v.id, varMap));
        const allRelevant = new Set([...topLevel.map(v => v.id)]);
        nestedWithPaths.forEach(path => path.forEach(node => allRelevant.add(node.id)));
        
        varsToShow = allVariables.filter(v => allRelevant.has(v.id));
      } else {
        varsToShow = filteredVariables.length > 0 ? filteredVariables : allVariables;
      }
      
      const tree = buildTree(varsToShow);
      container.innerHTML = '';
      
      function renderNode(node, depth = 0) {
        const div = document.createElement('div');
        div.className = 'variable-node';

        const firstMode = node.modes[0];
        const value = node.values ? node.values[firstMode] : null;
        const rawValue = node.rawValues ? node.rawValues[firstMode] : null;
        const resolvedType = node.varType || 'COLOR';
        const isMatch = matchedIds.has(node.id);

        const item = document.createElement('div');
        const hasUsageClass = node.totalUsage > 0 ? 'has-usage' : '';
        const matchClass = isMatch ? 'search-match' : '';
        item.className = `variable-item ${hasUsageClass} ${matchClass}`;

        const hasChildren = node.children && node.children.length > 0;
        const isExpanded = expandedNodes.has(node.id);
        const expandIcon = hasChildren
          ? `<span class="expand-icon">${isExpanded ? '▼' : '▶'}</span>`
          : '<span class="expand-icon"></span>';

        // Build preview based on variable type
        let previewHtml = '';
        if (resolvedType === 'COLOR') {
          // For colors, show the color swatch
          if (rawValue && rawValue !== 'alias') {
            previewHtml = `<div class="color-preview" style="background-color: ${rawValue}"></div>`;
          }
        } else {
          // For other types, show the value
          if (value && value !== 'alias') {
            const valueClass = resolvedType === 'FLOAT' ? 'number' :
                              resolvedType === 'STRING' ? 'string' :
                              resolvedType === 'BOOLEAN' ? 'boolean' : '';
            previewHtml = `<span class="value-preview ${valueClass}">${value}</span>`;
          }
        }
        
        const usageClass = node.totalUsage > 0 ? 'has-usage' : '';
        const highlightedName = highlightText(node.name, searchQuery);

        // Build usage breakdown tooltip
        let usageBreakdownHtml = '';
        if (node.usageBreakdown && node.totalUsage > 0) {
          const b = node.usageBreakdown;
          usageBreakdownHtml = `
            <div class="usage-breakdown-tooltip">
              <div class="usage-breakdown-row total">
                <span class="label">Total:</span>
                <span class="value">${b.total}</span>
              </div>
              <div class="usage-breakdown-row component">
                <span class="label">Component:</span>
                <span class="value">${b.componentLevel}</span>
              </div>
              <div class="usage-breakdown-row instance">
                <span class="label">Instance:</span>
                <span class="value">${b.instanceLevel}</span>
              </div>
              <div class="usage-breakdown-row detached">
                <span class="label">Detached:</span>
                <span class="value">${b.detached}</span>
              </div>
            </div>
          `;
        }

        let selectorHtml = '';
        if (node.componentIds && node.componentIds.length > 0) {
          const currentIndex = componentSelectionIndex.get(node.id) || 0;
          const total = node.componentIds.length;

          // Get current node info for badge
          let nodeBadge = '';
          if (node.nodeUsageInfo && node.nodeUsageInfo[currentIndex]) {
            const info = node.nodeUsageInfo[currentIndex];
            const badgeType = info.type === 'COMPONENT' || info.type === 'COMPONENT_SET' ? 'component' :
                             info.type === 'INSTANCE' ? 'instance' : 'detached';
            nodeBadge = `<span class="node-type-badge ${badgeType}">${info.type.substring(0, 4)}</span>`;
          }

          selectorHtml = `
            <div class="component-selector" data-node-id="${node.id}">
              <button class="component-nav-btn prev" ${currentIndex === 0 ? 'disabled' : ''}>◀</button>
              <span class="component-info" title="Click to navigate">${currentIndex + 1}/${total}</span>
              ${nodeBadge}
              <button class="component-nav-btn next" ${currentIndex === total - 1 ? 'disabled' : ''}>▶</button>
            </div>
          `;
        }
        
        item.innerHTML = `
          ${expandIcon}
          ${previewHtml}
          <span class="variable-name">${highlightedName}</span>
          <span class="usage-count ${usageClass}">${node.totalUsage}↓</span>
          ${usageBreakdownHtml}
          ${selectorHtml}
        `;
        
        div.appendChild(item);
        
        if (hasChildren) {
          const childrenDiv = document.createElement('div');
          childrenDiv.className = `children ${isExpanded ? 'expanded' : ''}`;
          node.children.forEach(child => {
            childrenDiv.appendChild(renderNode(child, depth + 1));
          });
          div.appendChild(childrenDiv);
          
          item.addEventListener('click', (e) => {
            if (e.target.closest('.component-selector') || e.target.closest('.component-nav-btn')) {
              return;
            }
            
            if (expandedNodes.has(node.id)) {
              expandedNodes.delete(node.id);
            } else {
              expandedNodes.add(node.id);
            }
            renderTreeView();
          });
        }
        
        const selector = item.querySelector('.component-selector');
        if (selector) {
          const nodeId = selector.getAttribute('data-node-id');
          const variable = allVariables.find(v => v.id === nodeId);

          const prevBtn = selector.querySelector('.prev');
          const nextBtn = selector.querySelector('.next');
          const infoSpan = selector.querySelector('.component-info');

          if (prevBtn) {
            prevBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const currentIndex = componentSelectionIndex.get(nodeId) || 0;
              if (currentIndex > 0) {
                componentSelectionIndex.set(nodeId, currentIndex - 1);
                selectComponent(variable, currentIndex - 1);
                renderTreeView();
              }
            });
          }

          if (nextBtn) {
            nextBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const currentIndex = componentSelectionIndex.get(nodeId) || 0;
              if (currentIndex < variable.componentIds.length - 1) {
                componentSelectionIndex.set(nodeId, currentIndex + 1);
                selectComponent(variable, currentIndex + 1);
                renderTreeView();
              }
            });
          }

          // Click on info to navigate to current selection
          if (infoSpan) {
            infoSpan.addEventListener('click', (e) => {
              e.stopPropagation();
              const currentIndex = componentSelectionIndex.get(nodeId) || 0;
              selectComponent(variable, currentIndex);
            });
          }
        }
        
        return div;
      }
      
      tree.forEach(root => {
        container.appendChild(renderNode(root));
      });
    }

    function selectComponent(variable, index) {
      if (variable && variable.componentIds && variable.componentIds[index]) {
        parent.postMessage({ 
          pluginMessage: { 
            type: 'select-components', 
            componentIds: [variable.componentIds[index]]
          } 
        }, '*');
      }
    }

    function renderGraph() {
      const canvas = document.getElementById('graph-canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = canvas.offsetWidth * window.devicePixelRatio;
      canvas.height = canvas.offsetHeight * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      
      const width = canvas.offsetWidth;
      const height = canvas.offsetHeight;
      
      const varsToShow = filteredVariables.length > 0 ? filteredVariables : allVariables;
      
      if (varsToShow.length === 0) {
        ctx.fillStyle = '#888';
        ctx.font = '14px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('No variables to display', width / 2, height / 2);
        return;
      }
      
      const tree = buildTree(varsToShow);
      const nodeWidth = 180;
      const nodeHeight = 40;
      const levelGap = graphOrientation === 'vertical' ? 100 : 200;
      const siblingGap = graphOrientation === 'vertical' ? 40 : 80;
      
      const allNodes = [];
      const links = [];
      
      function assignLevels(node, level = 0) {
        if (!node._visited) {
          node._visited = true;
          node.level = level;
          allNodes.push(node);
          
          if (node.children && node.children.length > 0 && !collapsedNodes.has(node.id)) {
            node.children.forEach(child => {
              assignLevels(child, level + 1);
              links.push({ source: node, target: child });
            });
          }
        }
      }
      
      tree.forEach(root => assignLevels(root));
      
      const levelGroups = {};
      allNodes.forEach(node => {
        if (!levelGroups[node.level]) levelGroups[node.level] = [];
        levelGroups[node.level].push(node);
      });
      
      const startMargin = 60;
      
      Object.keys(levelGroups).forEach(level => {
        const nodes = levelGroups[level];
        
        if (graphOrientation === 'vertical') {
          const totalWidth = nodes.length * nodeWidth + (nodes.length - 1) * siblingGap;
          const startX = Math.max(startMargin, (width - totalWidth) / 2);
          
          nodes.forEach((node, i) => {
            node.x = startX + i * (nodeWidth + siblingGap) + nodeWidth / 2;
            node.y = startMargin + parseInt(level) * levelGap;
          });
        } else {
          const totalHeight = nodes.length * nodeHeight + (nodes.length - 1) * siblingGap;
          const startY = Math.max(startMargin, (height - totalHeight) / 2);
          
          nodes.forEach((node, i) => {
            node.x = startMargin + parseInt(level) * levelGap;
            node.y = startY + i * (nodeHeight + siblingGap) + nodeHeight / 2;
          });
        }
      });
      
      ctx.save();
      ctx.translate(graphPanX, graphPanY);
      ctx.scale(graphZoom, graphZoom);
      
      ctx.clearRect(-graphPanX / graphZoom, -graphPanY / graphZoom, width / graphZoom, height / graphZoom);
      
      links.forEach(link => {
        const isHighlighted = selectedNodeId && 
          (link.source.id === selectedNodeId || link.target.id === selectedNodeId ||
           isInPath(link.source.id, selectedNodeId) || isInPath(link.target.id, selectedNodeId));
        
        ctx.strokeStyle = isHighlighted ? '#0d99ff' : '#3d3d3d';
        ctx.lineWidth = isHighlighted ? 3 : 2;
        
        ctx.beginPath();
        ctx.moveTo(link.source.x, link.source.y + nodeHeight / 2);
        
        if (graphOrientation === 'vertical') {
          const midY = (link.source.y + link.target.y) / 2;
          ctx.bezierCurveTo(
            link.source.x, midY,
            link.target.x, midY,
            link.target.x, link.target.y - nodeHeight / 2
          );
        } else {
          const midX = (link.source.x + link.target.x) / 2;
          ctx.bezierCurveTo(
            midX, link.source.y,
            midX, link.target.y,
            link.target.x - nodeWidth / 2, link.target.y
          );
        }
        
        ctx.stroke();
      });
      
      allNodes.forEach(node => {
        const firstMode = node.modes[0];
        const rawValue = node.rawValues ? node.rawValues[firstMode] : null;
        const value = node.values ? node.values[firstMode] : null;
        const resolvedType = node.varType || 'COLOR';

        const hasUsage = node.totalUsage > 0;
        const isSelected = node.id === selectedNodeId;
        const hasCollapsedChildren = node.children && node.children.length > 0 && collapsedNodes.has(node.id);

        ctx.fillStyle = isSelected ? '#394360' : '#2d2d2d';
        ctx.strokeStyle = isSelected ? '#0d99ff' : (hasUsage ? '#0d99ff' : '#3d3d3d');
        ctx.lineWidth = isSelected ? 4 : (hasUsage ? 3 : 2);

        const rectX = node.x - nodeWidth / 2;
        const rectY = node.y - nodeHeight / 2;

        ctx.fillRect(rectX, rectY, nodeWidth, nodeHeight);
        ctx.strokeRect(rectX, rectY, nodeWidth, nodeHeight);

        // Draw preview based on type
        if (resolvedType === 'COLOR' && rawValue && rawValue !== 'alias') {
          ctx.fillStyle = rawValue;
          ctx.fillRect(rectX + 8, rectY + 12, 16, 16);
          ctx.strokeStyle = '#3d3d3d';
          ctx.lineWidth = 1;
          ctx.strokeRect(rectX + 8, rectY + 12, 16, 16);
        } else if (resolvedType !== 'COLOR' && value && value !== 'alias') {
          // For non-color types, show a small value indicator
          ctx.fillStyle = resolvedType === 'FLOAT' ? '#8b5cf6' :
                         resolvedType === 'STRING' ? '#10b981' :
                         resolvedType === 'BOOLEAN' ? '#f59e0b' : '#888';
          ctx.font = 'bold 9px Monaco, monospace';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          const shortValue = value.length > 8 ? value.substring(0, 6) + '..' : value;
          ctx.fillText(shortValue, rectX + 8, rectY + 20);
        }

        ctx.fillStyle = '#e0e0e0';
        ctx.font = '11px Inter';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';

        let displayName = node.name;
        if (displayName.length > 20) {
          displayName = displayName.substring(0, 17) + '...';
        }

        ctx.fillText(displayName, rectX + 30, rectY + 12);
        
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'right';
        ctx.fillStyle = node.totalUsage > 0 ? '#0d99ff' : '#888';
        ctx.fillText(node.totalUsage + '↓', rectX + nodeWidth - 8, rectY + 12);
        
        ctx.fillStyle = '#888';
        ctx.font = '9px Inter';
        ctx.textAlign = 'left';
        ctx.fillText(node.collection, rectX + 30, rectY + 28);
        
        if (node.children && node.children.length > 0) {
          ctx.fillStyle = '#0d99ff';
          ctx.font = 'bold 12px Inter';
          ctx.textAlign = 'center';
          ctx.fillText(hasCollapsedChildren ? '+' : '−', rectX + nodeWidth - 16, rectY + 28);
        }
      });
      
      ctx.restore();
      
      canvas._nodes = allNodes;
      canvas._nodeWidth = nodeWidth;
      canvas._nodeHeight = nodeHeight;
    }

    function isInPath(nodeId, selectedId) {
      const visited = new Set();
      
      function checkPath(currentId) {
        if (currentId === selectedId) return true;
        if (visited.has(currentId)) return false;
        visited.add(currentId);
        
        const relationships = allRelationships.filter(r => r.from === currentId);
        for (const rel of relationships) {
          if (checkPath(rel.to)) return true;
        }
        
        const parentRels = allRelationships.filter(r => r.to === currentId);
        for (const rel of parentRels) {
          if (checkPath(rel.from)) return true;
        }
        
        return false;
      }
      
      return checkPath(nodeId);
    }

    document.getElementById('graph-zoom-in').addEventListener('click', () => {
      graphZoom = Math.min(graphZoom * 1.2, 3);
      renderGraph();
    });

    document.getElementById('graph-zoom-out').addEventListener('click', () => {
      graphZoom = Math.max(graphZoom / 1.2, 0.3);
      renderGraph();
    });

    document.getElementById('graph-reset').addEventListener('click', () => {
      graphZoom = 1;
      graphPanX = 0;
      graphPanY = 0;
      selectedNodeId = null;
      renderGraph();
    });

    document.getElementById('graph-expand-all').addEventListener('click', () => {
      if (collapsedNodes.size > 0) {
        collapsedNodes.clear();
        document.getElementById('graph-expand-all').textContent = 'Collapse All';
      } else {
        allVariables.forEach(v => {
          if (v.children && v.children.length > 0) {
            collapsedNodes.add(v.id);
          }
        });
        document.getElementById('graph-expand-all').textContent = 'Expand All';
      }
      renderGraph();
    });

    document.getElementById('graph-orientation').addEventListener('click', (e) => {
      graphOrientation = graphOrientation === 'vertical' ? 'horizontal' : 'vertical';
      e.target.textContent = graphOrientation === 'vertical' ? '↔ Horizontal' : '↕ Vertical';
      renderGraph();
    });

    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    const canvas = document.getElementById('graph-canvas');

    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left - graphPanX) / graphZoom;
      const y = (e.clientY - rect.top - graphPanY) / graphZoom;
      
      if (canvas._nodes) {
        const nodeWidth = canvas._nodeWidth || 180;
        const nodeHeight = canvas._nodeHeight || 40;
        
        for (const node of canvas._nodes) {
          const rectX = node.x - nodeWidth / 2;
          const rectY = node.y - nodeHeight / 2;
          
          if (x >= rectX && x <= rectX + nodeWidth && y >= rectY && y <= rectY + nodeHeight) {
            if (node.children && node.children.length > 0) {
              const btnX = rectX + nodeWidth - 24;
              const btnY = rectY + 16;
              if (x >= btnX && x <= btnX + 16 && y >= btnY && y <= btnY + 16) {
                if (collapsedNodes.has(node.id)) {
                  collapsedNodes.delete(node.id);
                } else {
                  collapsedNodes.add(node.id);
                }
                renderGraph();
                return;
              }
            }
            
            selectedNodeId = node.id === selectedNodeId ? null : node.id;
            renderGraph();
            return;
          }
        }
      }
      
      isDragging = true;
      dragStartX = e.clientX - graphPanX;
      dragStartY = e.clientY - graphPanY;
      canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        graphPanX = e.clientX - dragStartX;
        graphPanY = e.clientY - dragStartY;
        renderGraph();
      } else {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - graphPanX) / graphZoom;
        const y = (e.clientY - rect.top - graphPanY) / graphZoom;
        
        const tooltip = document.getElementById('tooltip');
        let found = false;
        
        if (canvas._nodes) {
          const nodeWidth = canvas._nodeWidth || 180;
          const nodeHeight = canvas._nodeHeight || 40;
          
          for (const node of canvas._nodes) {
            const rectX = node.x - nodeWidth / 2;
            const rectY = node.y - nodeHeight / 2;
            
            if (x >= rectX && x <= rectX + nodeWidth && y >= rectY && y <= rectY + nodeHeight) {
              const firstMode = node.modes[0];
              const value = node.values ? node.values[firstMode] : 'N/A';
              const resolvedType = node.varType || 'COLOR';

              const typeLabels = {
                'COLOR': 'Color',
                'FLOAT': 'Number',
                'STRING': 'String',
                'BOOLEAN': 'Boolean'
              };

              tooltip.innerHTML = `
                <div class="tooltip-title">${node.name}</div>
                <div class="tooltip-row">
                  <span class="tooltip-label">Type:</span>
                  <span>${typeLabels[resolvedType] || resolvedType}</span>
                </div>
                <div class="tooltip-row">
                  <span class="tooltip-label">Collection:</span>
                  <span>${node.collection}</span>
                </div>
                <div class="tooltip-row">
                  <span class="tooltip-label">Total usage:</span>
                  <span>${node.totalUsage} (incl. descendants)</span>
                </div>
                <div class="tooltip-row">
                  <span class="tooltip-label">Value:</span>
                  <span style="font-family: monospace; font-size: 10px;">${value || 'N/A'}</span>
                </div>
              `;
              tooltip.style.left = e.clientX + 10 + 'px';
              tooltip.style.top = e.clientY + 10 + 'px';
              tooltip.classList.add('visible');
              found = true;
              break;
            }
          }
        }
        
        if (!found) {
          tooltip.classList.remove('visible');
        }
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
      canvas.style.cursor = 'grab';
      document.getElementById('tooltip').classList.remove('visible');
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      graphZoom = Math.max(0.3, Math.min(3, graphZoom * delta));
      renderGraph();
    });

    window.addEventListener('resize', () => {
      if (document.getElementById('graph-view-container').classList.contains('active')) {
        renderGraph();
      }
    });

    function renderCollectionFilters() {
      const container = document.getElementById('collection-filters');
      container.innerHTML = '';

      const collections = [...new Set(allVariables.map(v => v.collection))].sort();

      // If no collections are explicitly selected, all are shown (selectedCollections is empty = show all)
      // If some are selected, only those are shown

      collections.forEach(collection => {
        const label = document.createElement('label');
        label.className = 'collection-filter-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        // Checked if: no filter active (show all) OR this collection is in the selected set
        checkbox.checked = selectedCollections.size === 0 || selectedCollections.has(collection);

        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            // User wants to SHOW this collection
            if (selectedCollections.size === 0) {
              // Currently showing all - do nothing, it's already visible
            } else {
              // Add to selected set
              selectedCollections.add(collection);
              // If all collections are now selected, clear the set (show all mode)
              if (selectedCollections.size === collections.length) {
                selectedCollections.clear();
              }
            }
          } else {
            // User wants to HIDE this collection
            if (selectedCollections.size === 0) {
              // Currently showing all - switch to showing all EXCEPT this one
              collections.forEach(c => {
                if (c !== collection) selectedCollections.add(c);
              });
            } else {
              // Remove from selected set
              selectedCollections.delete(collection);
              // If nothing is selected, that would hide everything - prevent that
              if (selectedCollections.size === 0) {
                // Re-add the collection (can't have empty selection)
                selectedCollections.add(collection);
                checkbox.checked = true;
                return;
              }
            }
          }
          renderCollectionFilters();
          applyFilters();
        });

        const span = document.createElement('span');
        span.textContent = collection;

        label.appendChild(checkbox);
        label.appendChild(span);
        container.appendChild(label);
      });
    }

    let feedbackTimeout = null;

    function showSelectionFeedback(message, isError = false) {
      const feedback = document.getElementById('selection-feedback');
      feedback.innerHTML = message;
      feedback.classList.toggle('error', isError);
      feedback.classList.add('visible');

      if (feedbackTimeout) clearTimeout(feedbackTimeout);
      feedbackTimeout = setTimeout(() => {
        feedback.classList.remove('visible');
      }, 3000);
    }

    window.onmessage = async (event) => {
      const msg = event.data.pluginMessage;

      if (msg.type === 'type-counts') {
        // Update the type counts in the filter screen
        typeCounts = msg.typeCounts;
        document.getElementById('count-color').textContent = `${typeCounts.COLOR || 0} variables`;
        document.getElementById('count-float').textContent = `${typeCounts.FLOAT || 0} variables`;
        document.getElementById('count-string').textContent = `${typeCounts.STRING || 0} variables`;
        document.getElementById('count-boolean').textContent = `${typeCounts.BOOLEAN || 0} variables`;
      } else if (msg.type === 'scan-complete') {
        allVariables = msg.data.variables;
        allRelationships = msg.data.relationships;
        filteredVariables = [];
        componentSelectionIndex.clear();

        // Update type counts if provided
        if (msg.data.typeCounts) {
          typeCounts = msg.data.typeCounts;
          document.getElementById('count-color').textContent = `${typeCounts.COLOR || 0} variables`;
          document.getElementById('count-float').textContent = `${typeCounts.FLOAT || 0} variables`;
          document.getElementById('count-string').textContent = `${typeCounts.STRING || 0} variables`;
          document.getElementById('count-boolean').textContent = `${typeCounts.BOOLEAN || 0} variables`;
        }

        document.getElementById('loading').style.display = 'none';
        document.getElementById('total-count').textContent = allVariables.length;

        renderCollectionFilters();
        renderTreeView();
      } else if (msg.type === 'scan-error') {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('tree-view').innerHTML =
          `<div class="empty-state" style="color: #f44336;">Error: ${msg.error}</div>`;
      } else if (msg.type === 'selection-complete') {
        const nodeInfo = msg.nodeInfo && msg.nodeInfo[0];
        if (nodeInfo) {
          showSelectionFeedback(`
            <span class="node-name">${nodeInfo.name}</span>
            <span class="node-type-badge ${nodeInfo.type === 'COMPONENT' || nodeInfo.type === 'COMPONENT_SET' ? 'component' : nodeInfo.type === 'INSTANCE' ? 'instance' : 'detached'}">${nodeInfo.type}</span>
            <div class="page-name">Page: ${msg.pageName}</div>
          `);
        }
      } else if (msg.type === 'selection-error') {
        showSelectionFeedback(`<span style="color: #f44336;">Error: ${msg.error}</span>`, true);
      }
    };

    // Resize handle
    const resizeCorner = document.getElementById('resize-corner');

    const resizeWindow = (e) => {
      const size = {
        w: Math.max(600, Math.floor(e.clientX + 5)),
        h: Math.max(400, Math.floor(e.clientY + 5))
      };
      parent.postMessage({ pluginMessage: { type: 'resize', size } }, '*');
    };

    resizeCorner.addEventListener('pointerdown', (e) => {
      resizeCorner.onpointermove = resizeWindow;
      resizeCorner.setPointerCapture(e.pointerId);
    });

    resizeCorner.addEventListener('pointerup', (e) => {
      resizeCorner.onpointermove = null;
      resizeCorner.releasePointerCapture(e.pointerId);
    });
  </script>
</body>
</html>